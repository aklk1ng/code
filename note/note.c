关键字：（关键字后留空格以突出关键字）
//auto     break     case      char     const     continue     default    do     double    else
//enum  extern（声明外部符号）   float   for   goto   if   int   long   register  return   short   signed
//sizeof   static  struct(结构体类型)   switch   typedef（类型重命名）   union   unsigned   void   volatile   while
//typerdef unsigned int u_int  将unsigned类型重命名为u_int，后续只需使用u_int
//include / define 不是关键字而是预处理指令
//static修饰全局变量后，全局变量只能在该源文件中使用
//EOF end of file文件结束标志

指针：
//32位——32根地址线——物理线——通电——1/0
//电信号转换为数字信号，1和0组成的二进制序列
//00000000000000000000000000000000     // 总共2^32种可能，以此为内存的编号并称为该内存单元的地址
//....                                 //4294967296 bit
//01000000000000000000000000000000     //536870912 byte
//....                                 //524288 kb
//11111111111111111111111111111111     //512 mb
                                       //0.5 gb
                                       //最终定为一个内存单元为一个字节
int * pa指pa为指针变量
//*说明pa为指针变量
//int说明pa执行的对象为int类型
*pa *为解引用操作，通过pa中的地址（仅第一个/最小的地址）找到变量
指针的大小是相同的，指针的大小取决于地址的存储需要多大的空间
//32位 32bit 指针大小为4byte
//64位 64bit 指针大小为8byte


操作符：
一元操作符：！ ~ ++ -- · &等前后不加空格
二元操作符：= += >= <= + * % && || << ^等前后加空格
-> []前后不加空格
//.操作符 结构体变量.成员变量
//->操作符 结构体指针->成员变量名
移位操作符不改变原变量
<<：左移操作符
把变量的二进制位向左移动一位
>>:右移操作符
1.算术右移：右边丢弃，左边补原符号位
2.逻辑右移：右边丢弃，左边补0
&-按（二进制）位与操作符    只用于整数
|-按（二进制）位或操作符    只用于整数
^-按（二进制）位异或        只用于整数
a =     0000000000000101
b =     0000000000000011
a & b = 0000000000000001
a | b = 0000000000000111
a ^ b = 0000000000000001

 0 ^ a = a
 a ^ a = 0
&  只有两变量对应的二进制位均为1，结果为1，其余均为0
|  对应的二进制位有1则结果为1，均为0才为0
^  对应的二进制位相同为0，相异为1
~对一个变量的二进制数（补码）按位取反
！按逻辑取反
sizeof括号内的表达式不参与运算，仅在编译环节进行

修饰符 * 和 &应紧跟变量名

函数名后不留空格以区分关键字

语句：
if/else语句：
//else与最近的if匹配

switch语句：
break不是必须，只需符合逻辑，且最后的break最好添加，若无break则会选择接入点直到程序结束
//switch允许嵌套使用

while循环：
//break用于永久的循环
//continue跳过本次循环continue后面的代码，直接进行条件判断

for循环：
//     初始值 判断 调整           若 判断 省略，则结果恒为真
//for (exp1; exp2; exp3)  exp可以省略，符合输出效果即可
//exp1与exp2以前闭右开的风格

二分查找（test1.c）

strcmp 比较字符串是否相同 头文件为<string.h>
strcmp( exp1, exp2) 
若1<2，则返回<0
若相同，则返回0
若1>2，则返回>0

//辗转相除法 test7.c

goto语句适用于多层嵌套，用来多层跳出，但不能跨函数


strcpy函数，头文件为string.h
格式:strcpy(char *a, char *b);
    strcpy(arr1, arr2);
    //    目的地 源文件

memset函数，头文件为string.h
//               目标内存    设置值(整形) 替换字节个数  
格式；void *memset(void *ptr, int value, size_t mun);
            memset(arr, 'x', 5);

void函数返回类型则不用return


函数:
函数功能应单一且独立
函数可以嵌套调用与链式访问但不能嵌套定义
//              把一个函数的返回值作为另一个函数的参数
//实参:真实的参数，可以是常数，变量，表达式（函数）
//形参:在函数括号中的参数，还未开辟内存空间
形参只是实参的一份临时拷贝，改变形参不能改变实参
//函数调用完后就会销毁，只存在于函数中生效（生命周期与局部变量一致）
传值调用：为形参和实参分别创造内存空间
传址调用：形参与实参有了实际联系
printf函数返回的是打印在屏幕上的字符个数
return只能返回一个值
//函数递归需要限制条件，每运行一次就无限接近限制条件


stack overflow  栈溢出
栈区：局部变量，函数形参,调用函数时返回值临时的变量
堆区：动态内存分配的malloc/free calloc realloc
静态区：全局变量，静态变量


数组:
数组名是首元素的地址但当以下情况时
1.sizeof（数组名）时- 数组名表示整个数组 - 计算的是整个数组的大小
2.&数组名 - 数组名表示整个数组 - 取出的是整个数组的地址
数组地址与数组首元素地址的值相同但意义不同
&arr//1      2与3是相同的
&arr+1                         数组地址加十进制的40（10个元素）
arr//2       但与1不同
arr+1                          数组地址加十进制的4
&arr[0]//3   即使打印的内容相同
数组传参时只传递数组中第一个元素的地址，需要在外部算出个数在以参数形式传入形参
数组作为函数传参时，形参可以写成两种形式：
1.数组形式    void test(int arr[])
2.指针形式    void test(int* arr)
 
//                  数组本身就是指针类型
char arr1[5] = "bit" //b i t \0 0
char arr2[5] = {'b', 'i', 't'} //'b' 'i' 't' \0 \0
1.一维数组在内存中是连续存放的
2.随着数组下标的增长，地址由低到高变化
//二维数组(行数可不初始化)
int arr[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12}//三行四列的数组，每个元素都是整形
下标类似于直角坐标系
二维数组在内存中也是连续存放的
每行内部连续，换行也是连续的