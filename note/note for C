关键字：（关键字后留空格以突出关键字）
//auto     break     case      char     const     continue     default    do     double    else
//enum  extern（声明外部符号）   float   for   goto   if   int   long   register  return   short   signed
//sizeof   static  struct(结构体类型)   switch   typedef（类型重命名）   union   unsigned   void   volatile   while
//typedef unsigned int u_int  将unsigned类型重命名为u_int，后续只需使用u_int
//include / define 不是关键字而是预处理指令
//static修饰全局变量后，全局变量只能在该源文件中使用
//EOF end of file文件结束标志

指针初阶：
const修饰指针变量时，
如果放在*左边，修饰*p，表示指针变量指向的内容，不能通过指针改变，
但是指针变量本身可以改变
如果放在*右边，修饰p，表示指针变量，表示指针变量不可改变，
但指针指定的内容可以被改变
如果*左右都有，修饰*p和p， 表示指针变量和指针指向的内容都不可以改变
//32位——32根地址线——物理线——通电——1/0
//电信号转换为数字信号，1和0组成的二进制序列
//00000000000000000000000000000000     // 总共2^32种可能，以此为内存的编号并称为该内存单元的地址
//....                                 //4294967296 bit
//01000000000000000000000000000000     //536870912 byte
//....                                 //524288 kb
//11111111111111111111111111111111     //512 mb
                                       //0.5 gb
                                       //最终定为一个内存单元为一个字节
int * pa指pa为指针变量
//*说明pa为指针变量
//int说明pa执行的对象为int类型
*pa *为解引用操作，通过pa中的地址（仅第一个/最小的地址）找到变量
指针的大小是相同的，指针的大小取决于地址的存储需要多大的空间
//32位 32bit 指针大小为4个字节
//64位 64bit 指针大小为8个字节

指针类型决定了
1.解引用的权限
2.指针每走一步，能走多远（步长）

野指针：指针指向的位置是未知的，随机的
原因：
1.指针未初始化   int* p = NULL 空指针
2.指针越界访问
3.指针指向的空间释放

指针运算：
1.整数
2.指针 指针-指针（相同内存空间）  得到指针之间的元素个数
标准规定指针可以与数组最后一个元素后面的内存进行比较，但不允许与第一个元素前的内存进行比较
3.关系运算（指针比较大小）

二级指针：
int a = 10;
int * pa = &a;
int* * ppa = &pa;

指针数组：存放地址的数组
int* parr[5]
char* pch[5]

数组指针：
指向数组的指针
int (*parr)[10] = &arr
parr为数组指针

一维数组传参：
若
int arr[10] = {0}
int* arr2[20] = {0}   //指针数组
则以下形式均相同
int arr[]
int arr[10]
int* arr

int* arr2[20]
int* *arr2
二维数组传参
若
int arr[3][5] = {0}
则以下形式均相同
int arr[3][5]
int arr[][5]
int (*arr)[5]



指针进阶：
常量字符串无法更改，因此不同的指针会指向相同的地址
一级指针传参：用一级指针接收
二级指针（指针数组/一级指针地址/二级指针变量）传参：用二级指针接收
函数指针：指向函数的指针，存放函数地址
函数名 == &函数名
用指针调用函数时，指针变量可以不用*，一样调用函数
(*(void (*)())0)()//调用0地址处的函数，该函数无参，返回类型为void
void (*)()  函数指针
(void (*)())0  对0进行强制类型转换，被解释为一个函数地址
*((void(*)())0)() 调用0地址处的函数

void (*signal(int, void(*)(int))) (int)
signal为函数，参数分别为int，函数指针
该函数指针指向一个参数为int，返回类型为void的函数
signal函数的返回类型也是一个函数指针
指向一个参数为int，返回类型为void
signal是一个函数声明
typedef void (*pun_t)(int)  对void(*)(int)的函数类型重命名为pun_t


函数指针数组：存放函数指针的数组
int (*parr[2])(int, int) = {add, sub}
parr为函数指针数组
指向函数指针数组的指针：
int (*(*p)[4])(int, int)
回调函数：通过函数指针调用另一个函数


int a[3][4] = {0}
sizeof(a + 1)表示二维数组第二行元素的地址
sizeof(a[0] + 1)表示第一行第二个元素

若p为ox100000
p+0x1为0x100014
(unsigned long)p + 0x1为0x100001
(unsigned int*)p + 0x1为0x100004
p[0]等价于*(p+0)

int a[3][2] = {(0,1), (2,3), (3,5)}
a数组中元素为 1 2 5 0 0 0





数据存储（数据在内存中以二进制的补码形式存储）
对于整数二进制来说有3种表示形式（原码，反码，补码）
原码与补码的相互转换，且运算方式相同
且正整数三者相同，负整数则要计算
整形
浮点型
构造类型   --自定义类型  数组    struct结构体类型  enum枚举  union联合体
指针类型
空类型

大端字节序：将数据的低位字节存储在高地址处，高位字节存储在低地址处
小端字节序：将数据的低位字节存储在低地址处，高位字节存储在高地址处


浮点数存储
任意一个二进制浮点数可以表示为
(-1)^S*M*2^E
(-1)^S表示符号位，当S等于o时，为正数，当S为1时，为负数
M表示有效数字，大于等于1，小于2
2^E表示指数位
浮点数5.5  十进制
二进制：101.1   -  1.011*2^2
(-1)^0 * 1.011 * 2^2
S=0   M=1.011  E=2+127
单精度浮点数在32个比特位中（字节由高到低）
S  1bit
E  8bit 存储时若E为8位，对存入时的真实值加上127
M  23bit 并没有存储整数部分的1，只保留小数部分，后续补0，读取时在添加，提高精度
双精度浮点数在64个比特位中（同上）
S  1bit
E  11bit 存储时若E为11位，对存入时的真实值加上1023
M  52bit

指数E从内存中取出时
1.E不全为0或不全为1
将内存中的值减去127（1023），得到真实值，再添上整数部分
2.E全为0
说明浮点数非常小，规定为1-127（1-1023）为真实值，
这时不在补整数部分，而是还原为0.xxxxxx的小数
3.E全为1
这时，如果有效数字M全为0，表示无穷大






结构体  传参时应用地址
struct 结构名
{
    成员变量；  //结构体成员可以是另一个结构体
    成员变量；
    成员变量；
}；s1，s2 //s1,s2也为结构变量但是全局变量
int main（）
{
    struct 结构名 变量名 //对象
}



栈，一种数据结构
先进后出，后进先出
存入数据为压栈，删除数据为出栈


栈区
先使用高地址空间，在使用低地址空间
在debug版本下可能导致死循环
而在release版本中会做优化，则可能不会造成死循环（变量创建的地址不同）




操作符：
一元操作符：！ ~ ++ -- · &等前后不加空格
二元操作符：= += >= <= + * % && || << ^等前后加空格
-> []前后不加空格
//.操作符 结构体变量.成员变量
//->操作符 结构体指针->成员变量名
移位操作符不改变原变量
<<：左移操作符
把变量的二进制位向左移动一位
>>:右移操作符
1.算术右移：右边丢弃，左边补原符号位
2.逻辑右移：右边丢弃，左边补0
&-按（二进制）位与操作符    只用于整数
|-按（二进制）位或操作符    只用于整数
^-按（二进制）位异或        只用于整数
a =     0000000000000101
b =     0000000000000011
a & b = 0000000000000001
a | b = 0000000000000111
a ^ b = 0000000000000001

 0 ^ a = a
 a ^ a = 0
&  只有两变量对应的二进制位均为1，结果为1，其余均为0
|  对应的二进制位有1则结果为1，均为0才为0
^  对应的二进制位相同为0，相异为1
~对一个变量的二进制数（补码）按位取反
！按逻辑取反
sizeof括号内的表达式不参与运算，仅在编译环节进行，可以仅通过类型进行计算
//整形提升：数据不足int类型长度时，将字节长度提升为int长度后
//送进cpu进行运算，再将结果截断，存储回变量
//整形提升时按照符号位提升，对于无符号的类型，统一补0

算术转换：当操作符属于不同的类型，按照字节长度更大的类型进行转换
算数顺序： 优先级>结合性>是否控制求值顺序 


修饰符 * 和 &应紧跟变量名

函数名后不留空格以区分关键字

语句：
if/else语句：
//else与最近的if匹配

switch语句：
break不是必须，只需符合逻辑，且最后的break最好添加，若无break则会选择接入点直到程序结束
//switch允许嵌套使用

while循环：
//break用于永久的循环
//continue跳过本次循环continue后面的代码，直接进行条件判断

for循环：
//     初始值 判断 调整           若 判断 省略，则结果恒为真
//for (exp1; exp2; exp3)  exp可以省略，符合输出效果即可
//exp1与exp2以前闭右开的风格

二分查找（test1.c）





字符串函数和字符函数：
//长度不受限制的函数：
strlen函数返回值为无符号整数，无符号数-无符号数=无符号数

strcmp 比较字符串是否相同 头文件为<string.h>
int strcmp( const char* exp1, const char* exp2)
比较的是每个字符串对应字符的ASCII码值
比较结束标志为\0
若exp1<exp2，则返回<0的值，vs实际值为-1
若相同，则返回0
若exp1>exp2，则返回>0的值，vs实际值为1

char* strcat(char* str, const char* str2)//追加字符串库函数
str为目标地址
str2为追加字符串的地址或直接为字符串
目标空间需足够大且可修改，追加开始标志为\0(覆盖),追加结束标志为\0
返回值为目标空间地址

strcpy函数，头文件为string.h
格式:char* strcpy(char *a, const char *b);
    strcpy(arr1, arr2);   
    //    目的地 源文件
要保证目标空间足够大且可修改（非常量字符串）
将b中的字符串拷贝放入a中，需要\0截止拷贝

const char* strstr(const char* str1, const char*str2)
在str1中查找是否包含str2的字符串
若包含，返回第一次出现str2内容的地址
若不包含，返回空指针


//长度不受限制的函数：
char* strncpy(char* str1, const char* str2, size_t num)
num为拷贝的字符串个数
若num大于拷贝的源字符串的总个数，则后续补\0进行拷贝

char* strncat(char* str, const char* str, sizr_t num)
可以追加原字符串并规定num为追加字符串大小
若num大于源字符串总个数，仍只会追加到\0
//辗转相除法 test7.c

char* strncmp(char* str1, const char* str2, size_t num)
num为比较的字符串个数

strtok函数（切割字符串）
char* strtok(char* str, const char* sep)
sep为字符串，作为分隔符的集合
每调用一次函数找一个分隔符
若strtok的第一个参数不为NULL
将找到第一个标记，并更改为\0，因此会更改字符串内容可先用临时拷贝进行分隔
并保存它在字符串中的位置（\0的位置）
当下次调用时若第一个参数为NULL时，将从上次记住的位置进行查找
若函数没有找到目标字符串，返回空指针

strerror头文件为string.h
char* strerror(int errnum)
调用库函数失败时，会设置错误码
错误吗存放在errno全局变量中，头文件为errno.h
返回错误码，并翻译成错误信息（字符串形式）

perror直接打印错误信息的函数，头文件为stdio.h
void perror(const char* str)
str中为需打印的自定义的字符串信息，同时添加： ，最后添加错误的信息
可以不用主动使用errno变量


字符分类函数：
int isdigit(ch)
头文件为ctype.h
判断ch中是否为数字字符
若是，返回非0的值
若不是，返回0

int islower(ch)
判断ch中是否为小写字母
若是，返回非0的值
若不是，返回0

字符转换：toupper/tolower
将字符转换为大/小写，并返回对应的字母
其它字符函数规则均相同


内存函数：
头文件均为string.h
memset内存设置函数
//               目标内存    设置值(整形) 替换字节个数  
格式；void *memset(void *ptr, int value, size_t mun);
            memset(arr, 'x', 5);
以字节为单位设置内存（可以将每个字节设置成01）
memcpy 内存拷贝函数
void* memcpy(void* dest, const void* source, size_t num)
num为拷贝的字节个数
拷贝空间不能重叠，但在vs中可以实现内存重叠的拷贝

memmove函数
格式与memcpy一致
可以实现内存重叠情况的拷贝
可以从前往后拷贝，也可以从后往前拷贝

memcmp内存比较函数
int memcmp(const void* str1, const void* str2, size_t num)
返回值与strcmp函数相同


void函数返回类型则不用return
goto语句适用于多层嵌套，用来多层跳出，但不能跨函数
函数:
函数功能应单一且独立
函数可以嵌套调用与链式访问但不能嵌套定义
//              把一个函数的返回值作为另一个函数的参数
//实参:真实的参数，可以是常数，变量，表达式（函数）
//形参:在函数括号中的参数，还未开辟内存空间
形参只是实参的一份临时拷贝，改变形参不能改变实参
//函数调用完后就会销毁，只存在于函数中生效（生命周期与局部变量一致）
传值调用：为形参和实参分别创造内存空间
传址调用：形参与实参有了实际联系（空间和时间利用效率更高）  通常情况下从右到左传参
printf函数返回的是打印在屏幕上的字符个数
return只能返回一个值
//函数递归需要限制条件，每运行一次就无限接近限制条件
qsort函数：快速排序，可以是升序也可以是降序。只需调换两函数指针的顺序
可以适用于任意类型
void qsort(void* base, size_t num, size_t size, int (*compar)(const void*, const coid*))
base为待排序数组中的第一个元素地址
num为待排序数据个数
size为待排序数据中每个元素的大小，单位为字节
int (*cpm)(const void*, const void*)用来比较待排序函数中的2个元素的函数（需要自己创建）




stack overflow  栈溢出
c/c++程序内存区域划分：
内核空间（用户代码不能读写）
栈区：（向下增长）局部变量，函数形参，调用函数时返回值临时的变量，返回地址
先使用高地址，在使用低地址

内存映射段：文件映射，动态库，匿名映射

堆区：（向上增长）动态内存开辟的malloc free calloc realloc
分配方式类似于链表

静态区（数据段）：全局变量，静态变量
程序结束后由系统释放

代码段：可执行代码/只读常量



数组:
数组名是首元素的地址但当以下情况时
1.sizeof（数组名）时
数组名表示整个数组
计算的是整个数组的大小
单位为字节
返回类型为unsigned int
2.&数组名 - 数组名表示整个数组 - 取出的是整个数组的地址
数组地址与数组首元素地址的值相同但意义不同
&arr//1      2与3是相同的
&arr+1                         数组地址加十进制的40（10个元素）
arr//2       但与1不同
arr+1                          数组地址加十进制的4
&arr[0]//3   即使打印的内容相同
数组传参时只传递数组中第一个元素的地址，需要在外部算出个数在以参数形式传入形参
数组作为函数传参时，形参可以写成两种形式：
1.数组形式    void test(int arr[])
2.指针形式    void test(int* arr)
 
//                  数组本身就是指针类型
char arr1[5] = "bit" //b i t \0 0
char arr2[5] = {'b', 'i', 't'} //'b' 'i' 't' \0 \0
1.一维数组在内存中是连续存放的
2.随着数组下标的增长，地址由低到高变化
//二维数组(行数可不初始化)
二维数组的数组名表示第一行的地址
int arr[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12}//三行四列的数组，每个元素都是整形
下标类似于直角坐标系
二维数组在内存中也是连续存放的
每行内部连续，换行也是连续的

柔性数组：
c99中，结构中的最后一个元素为未知大小的数组，这个成员就是柔性数组
柔性数组成员前必须有一个成员
sizeof返回的这种结构的大小不包括柔性数组的大小
包含柔性数组成员的结构分配内存时
用malloc函数分配内存，并且分配的内存大小必须大于结构体的大小，以适应柔性数组的预期大小

优势：
方便内存释放
有利于提高访问速度



自定义类型
结构体：一些值的集合，结构体的每个成员变量可以为不同类型
完全声明：struct name
name为结构体标签
不完全声明：(匿名结构体类型)-----只能使用一次
struct
{
    member——list
} s;
结构体自引用：结构体中包含其它或自身结构体类型
struct Node
{
    struct Node* next;
};

结构体内存对齐（结构体大小）
struct S
{
    char c2;//1
    int i;//4
    char c2;//1
};
规则：
第一个成员在与结构体变量偏移量为0的位置存放
其他成员要对齐到某个对齐数整数的整数倍的地址处
对齐数=编译器默认的一个对齐数与该成员占用大小的较小值

vs编译器默认对齐数为8
linux没有默认对齐数
结构体大小为结构体所有成员中对齐数中最大的对齐数的整数倍
如果嵌套了结构体，嵌套了的结构体对齐到自己的最大对齐数的整数倍出
结构体的总大小为所有结构体成员（含嵌套结构体）的最大对齐数的整数倍

内存对齐的意义：
平台（可移植）原因：不是所有硬件平台都能访问任意地址处的任意数据
某些硬件平台只能在某些地址处去某些特定类型的数据，否则抛出硬件异常
性能原因：数据结构应该在自然边界上对齐，这样内存可以一次读取某一数据
对于处理器访问未对其的内存，处理器要访问两次，而对齐的内存只要访问一次
结构体的内存对齐是拿空间换取时间的做法
在设计结构体时，为了节省空间并对齐，应让占用空间小的成员集中一起存放

修改默认对齐数（一般设置2的倍数）
#pragma pack(2)  //将默认对齐数改为2

#pragma pack()   //将默认对齐数修改为编译器值

offsetof头文件为stddef.h
计算成员变量相对于结构体首地址的偏移量
offsetof(type, member)

结构体传参（地址）  系统开销小

位段（vs）
位段的不确定性很多，且不跨平台，可移植程序应避免使用位段
位段的成员必须是整型家族 int，unsigned int，char
位段的成员名后边有一个冒号和数字
struct a
{
    int _a:2;
    int _b:5;
    int _c:10;
};
数字代表变量所占的bit位大小（节省一定的空间大小）
且最大为32
位段在开辟空间时按照4个字节（int）或1个字节（char）来开辟
成员变量从低位向高位使用，且但bit位不够时，再开辟空间使用



枚举    用来定义常量
格式
enum color
{
    exp1,
    exp2,
    ...
    expn
};
exp为可能的枚举类型（常量）
exp的值从第一个类型的值开始依次递增


联合（共用体）
联合类型定义的变量特征是使用同一块空间（从同一个内存开始使用）
同一时间只需使用其中一个成员（共同体）

联合体大小的计算：
联合体大小至少是最大成员的大小
当最大成员大小不是最大对齐数的整数倍时，对齐到最大对齐数的整数倍（语默认对齐数无关）






动态内存管理（堆区）：
头文件为stdlib.h
malloc：
void* malloc(size_t size)
size为开辟的字节数
如果开辟成功，返回空间的地址
若失败，返回空指针
void free(void* str)   用来回收和返还动态内存开辟的空间（堆区）
若str为空指针，则函数无实意
malloc和free基本成对使用

calloc：开辟一个数组空间，同时初始化数组为0
void* calloc(size_t num, size_t size)
num为元素个数
size为元素字节

realloc：函数执行实质为
若原地址后空间足够，直接添加所需的空间
若原地址后空间不够在堆区中重新找一块足够的空间，将原内容拷贝在创建的新空间，并将原空间还给操作系统
若找不到足够大空间，返回空指针
void* realloc(void* str, size_t size)
str为要调整的内存地址
size为调整后新大小
返回值为重新调整后的内存地址

动态开辟的空间的回收方式
1.主动free
2.程序结束

动态内存开辟常见的错误
1.对NULL指针进行解引用操作
2.对动态开辟的空间进行越界访问
3.对非动态开辟空间使用free释放
4.使用free释放动态开辟的内存空间的一部分
5.对同一块内存空间多次释放
6.动态开辟的空间忘记释放（内存泄漏：消耗内存）





文件：
一个程序可打开的文件是有限的，不关闭文件最后会无法打开文件
在程序设计中，有程序文件和数据文件
程序文件包括源程序文件，目标文件，可执行文件
数据文件包括程序运行时可读取的数据，不一定是程序
每个被使用的文件都在内存中创建了一个文件信息区，用来存放文件相关的信息
这些信息被保存在一个结构体变量中，该结构体类型有系统声明，取名FILE
不同的c编译器的FILE类型包含的内容不完全相同，但大同小异
每打开一个文件，系统自动创建一个这样的变量
一般通过一个FILE指针来维护这个结构体的变量

文件的打开与关闭
若文件打开失败返回空指针
FILE* fopen(const char* filename, const char* mode)
int fclose(FILE* stream)
filename可以只是文件名（与源文件在同一文件夹内），也可以是文件全部路径（反斜杠要用\\）
mode为打开方式
使用w方式时，即使文件中有内容也会在关闭文件后清空文件
stream为关闭文件的地址


文件的顺序读写（以文本形式写入与读取）：

int fputc(const char* string, FILE* stream)
将一个字符串写入到输出流或目标文件地址中

int fgetc(char* string, int n, FILE* stream)
n为最多读取的字符个数（比实际多一，预留了一个\0）
从标准输入流中读取一个字符串
若读取正常，返回该字符的ASCII值
若失败，返回EOF(-1)

fprintf(FILE* stream, const char* format...)
将取格式化的数据写入文件

fscanf(FILE* stream, const char* format...)
格式化输入函数

以二进制形式读写文件
size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream)
buffer为要写入数据的地址
size为元素的大小，单位为字节
count为最多写入的元素个数

size_t fread(const void* buffer, size_t size, size_y count, FILE* stream)


文件的随机读写：
int fseek(FILE* streeam, long offset, int origin)
根据文件指针的位置与偏移量读取文件
offset为偏移量
origin为起始位置：
1.当前指针位置 SEEK_CUR
2.文件末尾   SEEK_END
3.文件起始位置  SEEK_SET

long int ftell(FILE* stream)
返回文件指针当前位置相对于起始位置的偏移量

void rewind(FILE* stream)
让文件指针回到起始位置


文本文件与二进制文件：
二进制文件：数据在内存中直接以二进制形式存储，不加转换的输出到外存
文本文件：在外存中以ASCII码的形式（每一个字符都用ASCII表上的数字在用二进制展开）存储，需要在存储前进行转换

文件读取结束的判别：
1.被错误使用的feof
在文件读取过程中，不能使用feof函数的返回值直接来判断文件是否结束
应该用于当文件读取结束时，判断读取失败结束，还是遇到文件末尾结束

判断文件是否读取结束时应用EOF（fgetc）或NULL（fgets）


文件缓冲区：
ANSIC标准采用“缓冲文件系统”来处理数据文件的，即系统自动地在内存中为程序中每一个正在使用的文件开辟一块“文件缓冲区”
从内存向磁盘输出数据会先送到内存中的文件缓冲区，装满（输出）缓冲区后才一起送到磁盘上
如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存（输入）缓冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到数据区（程序变量等）
缓冲区的大小是由c编译系统决定的
fflush(FILE* stream)  刷新缓冲区，才将缓冲区的数据写到文件（磁盘）
fclose在关闭文件时，也会刷新缓冲区


流：
程序------->     流    ----------->      屏幕/硬盘/u盘/光盘/网络/软盘
写文件时是在文件流中写文件
c语言程序，只要运行起来，默认打开3个流（均为FILE*型）：
stdin---标准输入流---键盘
stdout---标准输出流---屏幕
stderr---标准错误流---屏幕

scanf      针对标准输入的格式化的输入语句  -  stdin
fscanf     针对所有输入流的格式化的输入语句 - stdin/文件
int ssanf(char* buffer, const char* format..)      
从一个字符串中读取一个格式化数据

printf     针对标准输出的格式化的输出语句   -  stdout
fprintf    针对所有输出流的格式化的输出语句  - stdout/文件
int sprintf(char* buffer, const char* format...)
把格式化数据转换成字符串







程序环境与预处理
程序环境：
1.翻译环境

预编译（预处理）：进行文本操作
完成对头文件的包含
完成define定义的宏和符号的替换操作
完成对注释的删除
（linux）gcc test.c -E在预处理之后停止

编译
语法分析
词法分析
语义分析
符号汇总
（linux）gcc test.i -S  生成test.s文件

汇编
生成符号表（对全局变量）
（linux）readelf指令查看汇编代码生成的符号表
把汇编代码转换成机器指令（二进制指令）
（linux）gcc test.s -c  生成test.o文件  格式为elf

链接
把多个目标文件（.o）和链接库进行链接
合并段表
符号表的合并和重定位

2.执行环境
程序执行时，程序将创建一个运行时堆栈，存储函数的局部变量和返回地址，
同时使用静态内存，存储于静态内存的变值一直在运行过程中保留它们的值





预处理：
1.预定符号：
__FILE__  打印源文件当前文件名及路径
__LINE__  打印当前行号
__DATE__  打印当前日期  
__TIME__  打印当前时间
__FUNCTION__  打印当前所位于的函数
__STDC__  若编译器遵循ANSIC，其值为1，否则错误

2.define：
定义常量
定义符号
定义宏：（将参数完全替换为文本）
在调用宏时，先检查参数是否有定义并将其替换成文本，在进行替换宏
预处理器在搜索宏时，不会对字符串常量的内容搜索
宏不能出现递归

在宏中把参数插入字符串
#a等效于"a"
将参数变成所对应的字符串
##将两个符号合成为一个符号（可以拓展到n个）

带副作用的宏参数：
当宏参数在宏的定义超过一次使用时，如果参数有副作用，会一直产生影响


宏和函数的对比：
优势：
1.在小型计算中，宏比函数在程序的规模和运算速度上更有优势

2.宏没有类型检查，而函数值用于一种具体类型

劣势：
1.在调用宏时，会增加代码的长度

2.宏无法调试

3.宏不够严谨
4.宏可能带来运算优先级的问题，导致程序发生错误

宏相较于函数独特的：
参数可以直接是类型
#define Malloc(num, type) (type*)malloc(num * sizeof(int))


#undef用于移除一个宏定义

3.命令行定义：
在命令行的方式进行定义
（linux）gcc test.c -D M=10

条件编译：
可以嵌套使用指令
1.
#if 常量表达式  由预处理器求值，若为真执行语句1，否则执行语句2
语句1
#endif
语句2
2.
#if 常量表达式    若为真，执行语句1，否则往下寻找为真的表达式进行执行语句
语句1
#elif 常量表达式
语句2
#else 常量表达式
语句3
#endif
语句4
3.
#ifdef/#if defined() 常量  如果定义该常量，执行语句1
语句1
#ifndef/#if !defined() 常量 如果没有定义，执行语句2
语句2
#endif
语句3


文件包含：
#include <> 库文件包含
直接去库目录下查找
#include ""  本地文件包含
先在源文件所在目录下查找，若无则在标准库函数的头文件中查找
linux中标准路径：
/usr/include

嵌套文件包含：
#pragma once 使文件只能被包含一次


offsetof计算结构体成员相对于起始位置的偏移量
头文件为stddef.h
size_t offestof(structname, membername)


对于gcc/g++编译器：
均可以编译C程序，编译程序的规则和参数都相同，g++编译时也会调用gcc
gcc和g++都可以自动链接标准C库，g++可以自动链接标准c++库
gcc要链接标准C++库，需要添加参数 -lstdc++
gcc和g++都可以定义__cplusplus宏


静态库和动态库：
1.静态库：
在linux中由程序ar生成
命名规则：
在linux中以lib为前缀,以.a为后缀
在Windows中,以lib为前缀,以lib为后缀
生成静态库：
先对源文件进行汇编操作（-c），得到二进制文件（-o），再使用ar工具将目标进行打包
使用ar时的参数：
c：创建一个库，无论是否存在
s：创建目标索引
r：在库中插入模块（替换）
使用静态库：
在gcc编译源文件时要使用制作的静态库，格式为：
gcc 源文件 -o 目标文件 -L 库的路径 -l 库的名字(去除前后缀(lib .a))
2.动态库：
动态链接库是程序运行时加载的库，当动态链接正确部署后，运行的多个程序可以使用同一个
加载到内存的动态库，因此也叫共享库
在linux中动态库以lib为前缀，以.so为后缀
在windows中以lib为前缀，以dll为后缀
生成动态库链接：
先生成二进制文件 gcc -c 源文件 -fpic(生成的代码是与位置无关的)
之后    gcc -shared(告诉编译器生成动态链接) 与位置无关的目标文件 -o 动态库名
